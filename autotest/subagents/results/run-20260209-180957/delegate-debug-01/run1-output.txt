I'll help you investigate this memory leak. Let me use a specialized debugging agent to perform a thorough analysis of potential memory leak sources in your codebase.

`â˜… Insight â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`
Memory leaks in Node.js/TypeScript applications typically stem from:
- **Unclosed resources**: Database connections, file handles, HTTP clients that aren't properly cleaned up
- **Event listener accumulation**: Listeners registered but never removed, especially in long-lived objects
- **Circular references**: While V8's GC handles most cases, closures holding references can prevent garbage collection
- **Global state**: Objects inadvertently stored in module-level variables or singletons

The manifestation at 1000+ requests suggests a per-request accumulation pattern rather than a one-time leak.
`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`
Perfect! The debugging agent has completed a comprehensive analysis. Let me provide you with the key findings and actionable next steps.

`â˜… Insight â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`
The investigation revealed **4 distinct memory leak patterns**, each with different accumulation rates:
1. **Unbounded caches** (Findings #1, #2) - grow linearly with requests, most predictable
2. **Cleanup path gaps** (Finding #3) - only leak on error paths, harder to detect
3. **Resource lifecycle issues** (Finding #4) - event listeners that outlive their objects

This multi-layered leak explains why it manifests after 1000+ requests - each leak is small per-request, but compounds over time.
`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`

## ðŸŽ¯ Root Cause Identified

The memory leak stems from **4 critical issues** across your application:

### **CRITICAL: Unbounded Webhook Signature Cache**
**File:** `tools/autopilot-server/src/services/webhook-verifier.ts:21-22`

The `WebhookVerifier` accumulates replay-prevention signatures without time-based expiration. Currently stores up to 10,000 signatures before cleanup, but should expire after 5 minutes.

**Impact:** ~64KB per 1000 requests

### **HIGH: Cache Manager Array Churn** 
**File:** `tools/claudeup-core/src/services/cache-manager.ts:323-328`

The LRU cache recreates entire arrays on every cache access. With high cache hit rates, this creates massive memory churn.

**Impact:** ~500KB per 1000 requests + memory pressure from allocations

### **MEDIUM: Session Tool ID Maps**
**File:** `tools/autopilot-server/src/services/claude-session-manager.ts:72`

Nested Maps tracking tool IDs don't clean up on certain error paths. Missing `finally` blocks allow Maps to leak when sessions fail unexpectedly.

**Impact:** ~28KB per 1000 requests

### **MEDIUM: Child Process Event Listeners**
**File:** `tools/autopilot-server/src/services/multi-model-reviewer.ts:404-449`

Spawned `claudish` processes attach event listeners that are never removed, even after timeout kills the process.

**Impact:** ~24KB per 1000 requests + potential zombie processes

---

## ðŸ“Š Combined Impact

At 10,000 requests, expect approximately **6.16MB** leaked, plus memory pressure from array churn and potential zombie processes.

## ðŸ”§ Recommended Action Plan

**Priority 1 (Immediate):** Fix the webhook signature cache with time-based expiration
**Priority 2 (High):** Replace array-based LRU tracking with order-number tracking
**Priority 3 (Medium):** Add `finally` blocks to session cleanup
**Priority 4 (Medium):** Properly remove child process event listeners

The agent has provided complete code fixes for each issue. Would you like me to:
1. Apply these fixes to the codebase?
2. Add heap profiling instrumentation to monitor improvements?
3. Create tests to verify the leak is resolved?
